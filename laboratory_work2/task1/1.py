from math import erf, sqrt, pi, exp

# Тестирование гипотезы
def hypothesis_test(x, n, p0=4 / 8, pa=3 / 8):
    """
    Функция для проверки гипотезы.
    Параметры:
        x  - наблюдаемое количество квадратных метров, которые плиточник выкладывает за час.
        n  - количество часов работы плиточника.
        p0 - вероятность в нулевой гипотезе (например, 4/8, что соответствует выкладке 4 кв. метров за час).
        pa - вероятность в альтернативной гипотезе (например, 3/8, что соответствует выкладке 3 кв. метров за час).
    Возвращает:
        p-value или False в случае, если нулевая гипотеза не опровергается.
    """
    alpha = 0.05  # Уровень значимости (вероятность ошибки первого рода)
    beta = 0.92  # Мощность проверки (вероятность не допустить ошибки второго рода)

    # Вычисляем математическое ожидание для нулевой и альтернативной гипотез
    mean0 = n * p0  # Мат. ожидание при нулевой гипотезе
    mean1 = n * pa  # Мат. ожидание при альтернативной гипотезе

    # Вычисляем стандартное отклонение для обеих гипотез
    std_dev0 = sqrt(n * p0 * (1 - p0))  # Стандартное отклонение при нулевой гипотезе
    std_deva = sqrt(n * pa * (1 - pa))  # Стандартное отклонение при альтернативной гипотезе

    # Находим критические точки (границы отклонения) для нулевой гипотезы
    lower_bound = inv_f_norm(alpha / 2, mean0, std_dev0)  # Нижняя критическая точка
    upper_bound = 2 * mean0 - lower_bound  # Верхняя критическая точка

    # Вычисляем мощность проверки
    test_power = (1 - f_norm(upper_bound, mean1, std_deva) +
                  f_norm(lower_bound, mean1, std_deva))

    # Вычисляем p-value для теста
    p = p_value(x / 8, mean0, std_dev0)

    # Если p-value больше уровня значимости и мощность проверки >= beta, нулевая гипотеза не отвергается
    if p >= alpha and test_power >= beta:
        print("Нулевая гипотеза не опровергнута")  # Гипотеза не опровергнута
        print(f"Мощность проверки равна {test_power}")  # Выводим мощность проверки
        return p  # Возвращаем p-value
    return False  # Если гипотеза отвергнута, возвращаем False

# Функция для расчета количества часов для выкладки плитки
def determine_tile_hours(j):
    """
    Функция для определения количества часов, за которое плиточник выкладывает заданное количество плитки.
    Параметры:
        j - общее количество квадратных метров плитки.
    Цикл перебирает количество часов и сравнивает гипотезы, чтобы определить правильный результат.
    """
    for i in range(100, 10000):  # Перебираем количество часов от 100 до 10000
        hypothesis3 = hypothesis_test(j, i, 3 / 8, 4 / 8)  # Проверяем гипотезу для 3 кв. м/час
        hypothesis4 = hypothesis_test(j, i)  # Проверяем гипотезу для 4 кв. м/час

        # Если обе гипотезы верны, сравниваем их p-value
        if bool(hypothesis3) and bool(hypothesis4) and hypothesis3 > hypothesis4:
            print(f"Верны обе теории. Плиточник выкладывает 3 кв метра плитки в час\nКоличество часов {i}")
            break
        elif bool(hypothesis3) and bool(hypothesis4):
            print(f"Верны обе теории. Плиточник выкладывает 4 кв метра плитки в час\nКоличество часов {i}")
            break

        # Если верна только одна гипотеза
        if bool(hypothesis4):
            print(f"Плиточник выкладывает 4 кв метра плитки в час\nКоличество часов {i}")
            break
        if bool(hypothesis3):
            print(f"Плиточник выкладывает 3 кв метра плитки в час\nКоличество часов {i}")
            break

# Нормальное распределение (CDF)
def f_norm(x, mu=0, s=1):
    """
    Вычисляет функцию распределения (CDF) для нормального распределения.
    Параметры:
        x  - значение случайной величины.
        mu - математическое ожидание (среднее).
        s  - стандартное отклонение.
    Возвращает:
        Значение функции распределения для заданного x.
    """
    return (1 + erf((x - mu) / sqrt(2) / s)) / 2

# Плотность вероятности нормального распределения (PDF)
def rho_norm(x, mu=0, s=1):
    """
    Вычисляет плотность вероятности (PDF) для нормального распределения.
    Параметры:
        x  - значение случайной величины.
        mu - математическое ожидание (среднее).
        s  - стандартное отклонение.
    Возвращает:
        Значение плотности вероятности для заданного x.
    """
    return 1 / sqrt(2 * pi * s) * exp(-(x - mu) ** 2 / (2 * s ** 2))

# Вероятность ошибки первого рода (p-value)
def p_value(x, mu=0, s=1):
    """
    Вычисляет p-value, вероятность ошибки первого рода.
    Параметры:
        x  - наблюдаемое значение.
        mu - математическое ожидание (среднее).
        s  - стандартное отклонение.
    Возвращает:
        p-value.
    """
    return 2 * (1 - f_norm(x, mu, s)) if x >= mu else 2 * f_norm(x, mu, s)

# Обратная функция распределения (inverse CDF)
def inv_f_norm(p, mu, s, t=0.001):
    """
    Вычисляет обратную функцию распределения (inverse CDF) для нормального распределения.
    Параметры:
        p  - вероятность.
        mu - математическое ожидание (среднее).
        s  - стандартное отклонение.
        t  - точность вычисления (по умолчанию 0.001).
    Возвращает:
        Значение x, такое что CDF(x) = p.
    """
    if mu != 0 or s != 1:
        return mu + s * inv_f_norm(p, 0, 1, t)  # Приводим к стандартной форме, если mu != 0 или s != 1

    # Определяем границы поиска
    low_x, low_p = -100, 0
    hi_x, hi_p = 100, 1

    # Используем бинарный поиск для нахождения x с требуемой точностью
    while hi_x - low_x > t:
        mid_x = (low_x + hi_x) / 2
        mid_p = f_norm(mid_x)
        if mid_p < p:
            low_x, low_p = mid_x, mid_p
        elif mid_p > p:
            hi_x, hi_p = mid_x, mid_p
        else:
            break
    return mid_x

# Основная функция
def main():
    determine_tile_hours(700)

# Запуск программы
if __name__ == "__main__":
    main()
